<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://liuyi98.github.io/al-folio/feed.xml" rel="self" type="application/atom+xml"/><link href="https://liuyi98.github.io/al-folio/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-09T21:43:09+00:00</updated><id>https://liuyi98.github.io/al-folio/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Well ground Java Developer</title><link href="https://liuyi98.github.io/al-folio/blog/2023/Well-ground-Java-Developer/" rel="alternate" type="text/html" title="Well ground Java Developer"/><published>2023-02-15T00:00:00+00:00</published><updated>2023-02-15T00:00:00+00:00</updated><id>https://liuyi98.github.io/al-folio/blog/2023/Well%20ground%20Java%20Developer</id><content type="html" xml:base="https://liuyi98.github.io/al-folio/blog/2023/Well-ground-Java-Developer/"><![CDATA[<h2 id="chapter-1-introduction-to-modern-java">Chapter 1 Introduction to modern Java</h2> <h3 id="java-语言与平台">Java 语言与平台</h3> <p>提起Java这个词，很多人第一印象都是Java语言。Java语言在从出生开始到现在这30年里一直叱咤风云。但是在现代意义上讲，Java代表的已经不局限于Java语言了，而是Language + Platform。大体上讲，Java这个商标由Oracle拥有并管理。Oracle负责Java SE的开发，根据Java SE官网，Java SE 19的标准分为两部分：</p> <ul> <li> <p>The Java Language Specification, Java SE 19 Edition</p> <p>Preview feature: Pattern Matching for switch； Record Patterns</p> </li> <li> <p>The Java Virtual Machine Specification, Java SE 19 Edition</p> </li> </ul> <p>其中 The Java Language指的就是那门原教旨面向对象的编程语言，而Java Virtual Machine就是Java程序员面试需要背诵但是从来都用不上的JVM。实际上JVM的官方实现已经没有任何和Java语言相关的字眼，对于JVM来说Java语言和其他任何一个可以编译为Bytecode的语言（Kotlin或Scala）一样。</p> <h3 id="java-发布模型">Java 发布模型</h3> <p>从2021年开始，Java每两年一个LTS，半年一个STS（看起来像是被别的语言刺激了）。 值得注意的是，JDK中有一些独立的OpenJDK project可能贯穿多个JDK的生命周期，每个project做的事情都不一样。比如Project Loom致力于在Java中实现协程，而Project Amber致力于让程序员少写代码。</p> <h2 id="chapter-13-testing-fundamentals">Chapter 13 Testing Fundamentals</h2> <h3 id="131-如何测试">13.1 如何测试？</h3> <p>软件的测试大致可以分为：</p> <ul> <li>单元测试</li> <li>集成测试</li> <li>端到端测试</li> </ul> <p>他们之间的关系可以用一个金字塔来表示：</p> <p><img src="/assets/img/pyramid.png" alt="pasad" title="the pyramin"/></p> <p><strong>单元测试：</strong> 单元测试构成了整个金字塔的最底部。每个单元测试之间的隔离性最强，运行速度最快，所覆盖的内容也最单一。理想状态下，单个单元测试应该只测试单个功能。这里的单个功能指的是：自己的与外部依赖无关的逻辑。当所测试的逻辑有外部依赖时，如使用了数据库调用或者RPC，外部依赖返回的结果应该使用Mock的理想结果，这个叫做test double。</p> <p><strong>集成测试：</strong> 集成测试和单元测试之间的关系有时是模糊的。但仍然可以确定的是：集成测试只测试整个系统的一部分，另外仍有一部分依赖是被Mock的。比如：一个测试只测试某个后端服务的一个借口，这个后端服务中使用真实的数据库和RPC连接，而假定前端部分是完美的。</p> <p><strong>端到端测试：</strong> 端到端测试是最直观的测试，就是假定自己是用户，测试整个系统的输出是否与自己所期望的相匹配。</p> <h2 id="132-测试驱动开发">13.2 测试驱动开发</h2>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Chapter 1 Introduction to modern Java]]></summary></entry><entry><title type="html">Java SE, Java EE, and Spring Framework</title><link href="https://liuyi98.github.io/al-folio/blog/2022/Java-SE,-Java-EE,-and-Spring-Framework/" rel="alternate" type="text/html" title="Java SE, Java EE, and Spring Framework"/><published>2022-11-05T00:00:00+00:00</published><updated>2022-11-05T00:00:00+00:00</updated><id>https://liuyi98.github.io/al-folio/blog/2022/Java%20SE,%20Java%20EE,%20and%20Spring%20Framework</id><content type="html" xml:base="https://liuyi98.github.io/al-folio/blog/2022/Java-SE,-Java-EE,-and-Spring-Framework/"><![CDATA[<p>I didn’t know what exactly Java EE is for a long time. After reading a whole bunch of documents from Spring/Eclipse/Wikipedia, finally I understand the relationship between those technologies.</p> <h3 id="java-se">Java SE</h3> <p>Java Standard Edition is what usually we call ‘Java’. OpenJDK is the official reference implementation. It consists of both Java Language Specification, Java Library, and Java Virtual Machine Specification. So Java SE and JDK can be used interchangeably.</p> <h3 id="java-ee">Java EE</h3> <p>Java Enterprise Edition is a collection of specifications. It consists of APIs like web service(Servlet), persistence(JPA), Bean validation, Json data-bind, annotation, mail, and transaction management. To use these specifications, you will have to import both the specification itself and its implementation. For example, if you want to write a web server, you will have to write it with Servlet and let your program run in a Servlet container like Apache Tomcat or Jetty. If you want operation with a database, you will probably use JPA and one of its implementation Hibernate ORM. In a nutshell, Java EE is a series of specifications that can boost the development of enterprise Java programs. There may be multiple implementations for every specification, such as Jetty, Glassfish, and Apache Tomcat for Servlet.</p> <h3 id="spring-framework">Spring Framework</h3> <p>You may consider it strange to place Spring here because it does different things with Java SE and Java EE. However, according to Spring’s documentation, it does have some relationship with them. Spring was started as a response to the complexity of J2EE, it selects some specific Java EE specifications like Servlet instead of embracing the whole of it, which makes Spring more light-weighted and easier to use.</p>]]></content><author><name></name></author><category term="随想"/><summary type="html"><![CDATA[I didn’t know what exactly Java EE is for a long time. After reading a whole bunch of documents from Spring/Eclipse/Wikipedia, finally I understand the relationship between those technologies.]]></summary></entry><entry><title type="html">信息建索的评价</title><link href="https://liuyi98.github.io/al-folio/blog/2021/%E4%BF%A1%E6%81%AF%E5%BB%BA%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/" rel="alternate" type="text/html" title="信息建索的评价"/><published>2021-12-21T00:00:00+00:00</published><updated>2021-12-21T00:00:00+00:00</updated><id>https://liuyi98.github.io/al-folio/blog/2021/%E4%BF%A1%E6%81%AF%E5%BB%BA%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7</id><content type="html" xml:base="https://liuyi98.github.io/al-folio/blog/2021/%E4%BF%A1%E6%81%AF%E5%BB%BA%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/"><![CDATA[<p>Evaluation 对于一个新的信息建索算法，我们该如何去判断这个算法的好坏呢？ 宏观上来看，一个好的算法上线以后，用户的反馈会发生变：用户的点击更多，对于电商网站来说，用户花的钱更多，并且用户可能会有重复的点击行为。但是这些反馈很难量化地评估，因为在此期间可能页面的UI发生了变动，导致用户不喜欢这个网站。我们需要一个评估搜索算法好坏的标准。 实际上，搜索算法的评估需要三个元素：</p> <ol> <li>和大多数机器学习问题一样，搜索算法的评估需要一个数据集，</li> <li>测试的query</li> <li> <p>query和document之间的关联度。 前两者只要从日常的搜索日志中提取即可，但是如何评估一个query和搜索到的document的关联度的呢？</p> </li> <li>无排序搜索 无排序搜索将文档视为set，并不关心搜索结果的顺序，只关心搜索结果与query的相关性。对于一个搜索q，准确率 \(precision=\frac{搜索到的相关文档数量}{搜索到的文档数量}\) 召回率 \(recall=\frac{搜索到的相关文档数量}{相关文档数量}\) 更加准确地来说：</li> </ol> <p>relevant nonrelevant retrieved tp(true positive) fp(false positive) Not retrieved tn(true negetive) fn(fase negetive)</p> <p>\(p =\frac{tp}{tp+fp}\) 对于以上的四种情况来说，很明显tp和fn是准确的搜索结果：相关的都被搜到了，而不相关的都没有被搜到，所以可以很直观地得出一个无排序搜索的评价标准：accuracy \(r=\frac{tp+fn}{tp+fp+fn+tn}\) 对于很多机器学习的二分类问题来说这是一个很好的评价标准:正确的结果的比率，只不过此时的recall不再具有召回的意味。 召回率与查准率是一对相互冲突的指标，通常用F measure作为对两者的trade-off:F measure是两者的调和平均： \(f = \frac{1}{a\frac{1}{p}+(1-a)\frac{1}{r}}\) 然而对于搜索的问题来说，仍然存在一些问题：如果</p> <ol> <li>有排序搜索 考虑以下实例：对于一个搜索，结果集为 \(D_0, D_1, D_2, D_3, D_4, D_5\) 各结果对应的相关度为 \(3, 2, 3, 0, 1, 2\) 数字越大代表结果与搜索越相关。 CG, DCG和NDCG CG(cumulative gain)中文翻译为累计增益。此处用Gain这个词可能是因为，对于query的每一个结果，其相关度用数字来表示，如5表示非常理想，1表示根本毫无关联。这个相关度即可看作对于一个结果的增益，增益大的结果应当在结果集的上方出现。 顾名思义，CG为所有增益的累计， \(CG_p=\sum_{n=1} ^{p} rel_i\) 对于上面的例子： \(CG_6=3+2+3+0+1+2=11\) 结果集内元素的顺序的调换不会影响CG的大小，所以CG能衡量的内容比较有限。 DCG DCG(Discounted CG)，discount原意为商品打折，此处指gain加权， DCG: \(DCG=\sum_{n=1}^{p} \frac{rel_i}{log_2(i+1)}\) DCG给每一个结果的相关度乘以一个系数，这个系数大小随着位置的增大而减小。因此：更相关的结果排名靠后时，DCG会变小；越相关的结果排名越靠前，则DCG越大。 对于上面的例子， \(DCG_6=6.681\) DCG也有一些变种，但是也都换汤不换药，比如： \(DCG=\sum_{n=1}^{p} \frac{2^{rel_i} -1}{log_2(i+1)}\) DCG可以衡量一个query的结果集的排序的好坏，但是各个query的结果数量不一样，对于有多个query的数据集，DCG无法衡量两者排序的好坏，我们需要一个归一化的DCG NGCG(Normalized DCG) nDCG指归一化的DCG，对于一个query， \(nDCG=\frac{DCG_p}{max(DCG_p)}\) DCG的最大值即排序最理想的情况下的DCG，此时结果的排序与相关度的排序相同。很明显nDCG的取值范围为(0, 1]，可以用于跨query的比较。 使用nDCG的缺陷在于：很难获得完整</li> </ol>]]></content><author><name></name></author><category term="Information retrieval"/><summary type="html"><![CDATA[Evaluation 对于一个新的信息建索算法，我们该如何去判断这个算法的好坏呢？ 宏观上来看，一个好的算法上线以后，用户的反馈会发生变：用户的点击更多，对于电商网站来说，用户花的钱更多，并且用户可能会有重复的点击行为。但是这些反馈很难量化地评估，因为在此期间可能页面的UI发生了变动，导致用户不喜欢这个网站。我们需要一个评估搜索算法好坏的标准。 实际上，搜索算法的评估需要三个元素：]]></summary></entry><entry><title type="html">Linux\Unix简史</title><link href="https://liuyi98.github.io/al-folio/blog/2021/Linux,Unix%E7%AE%80%E5%8F%B2/" rel="alternate" type="text/html" title="Linux\Unix简史"/><published>2021-11-25T00:00:00+00:00</published><updated>2021-11-25T00:00:00+00:00</updated><id>https://liuyi98.github.io/al-folio/blog/2021/Linux,Unix%E7%AE%80%E5%8F%B2</id><content type="html" xml:base="https://liuyi98.github.io/al-folio/blog/2021/Linux,Unix%E7%AE%80%E5%8F%B2/"><![CDATA[<p>对于很多正在使用Windows进行日常工作的人来说，Linux和Unix听起来就像是？对于很多使用Mac OS的朋友来说，他们可能不知道自己正在使用的是也是Unix操作系统，那到底是什么是Unix和Linux？Mac OS和Unix又有什么关系呢？Andriod和Linux又有什么关系呢？</p> <p>操作系统和操作系统内核 对于程序员或者普通的电脑的使用者来说，当你拿到组装好的电脑之后，按下开机键，电脑启动，展示出漂亮的开机画面，你可以打开IDE边写代码边听歌，这一切都是怎么实现的呢？你的电脑可能只有一个CPU（现在估计不太可能了），那是怎么同时浏览网页又能听歌的呢？声卡为什么能播放声音？显卡为什么又能显示画面呢？这一切都是操作系统的工作。</p> <p>简要的来说，操作系统为程序员或使用电脑的人提供了一层抽象，程序员们不用管哪个牌子的CPU该怎么运算，不用管</p> <p>操作系统又分为核心功能和附加功能，核心功能就是操作系统让电脑运行的核心的模块，其在电脑开机时到电脑关闭始终处于运行模块，核心功能大抵包括：</p> <ul> <li>多任务及其上下文的切换</li> <li>内存管理</li> <li>不同厂商硬件的抽象</li> <li>文件管理 而仅有内核是不够的。我们仍然需要额外的 Unix和UNIX？ 操作系统的发展史拍一部电影来描述都不为过，而其中Unix的产生应该就是这部电影的开头了。 时间回到19xx年，时年xx岁的ken tompsen和rechie刚从xx回到位于xx的贝尔实验室的办公室，几天前他们还在同MIT的开发人员共同研制一个极为庞大的操作系统Multics（多用户多任务的操作系统 ）</li> </ul>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[对于很多正在使用Windows进行日常工作的人来说，Linux和Unix听起来就像是？对于很多使用Mac OS的朋友来说，他们可能不知道自己正在使用的是也是Unix操作系统，那到底是什么是Unix和Linux？Mac OS和Unix又有什么关系呢？Andriod和Linux又有什么关系呢？]]></summary></entry></feed>